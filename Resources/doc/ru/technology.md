# Технология работы

Общая схема работы бандла следующая:
1. Пользователь [узнаёт](logo-button.md) возможность указания ошибок в тексте.
2. Пользователь выделяет часть текста, в котором находится ошибка (либо саму 
ошибку, либо слово, в котором находится ошибка), и нажимает клавиши Ctrl+Enter.
3. Система показывает окно отправки ошибки. В окне показан текст, в котором 
выделенная ошибка. Пользователь может ввести комментарий (например, свой 
вариант исправления ошибки) и нажимает кнопку "Отправить" (или Ctrl+Enter).
4. Система принимает ошибку и комментарий, проверяет пользователя ([роль](auth-check.md))
и его [IP-адрес](flood-control.md) (возможно, выполняются [дополнительные 
проверки](custom-event-listener.md)), и сохраняет в базу данных. Если во время
проверок возникли ошибки, код и текст ошибки возвращается в фронтенд.
5. Если во время отправки ошибки не возникло ошибок в бэкенде, то окно ошибки
закрывается, иначе текст ошибки показывается пользователю.

## Работа скрипта spelling.js

Скрипт spelling.js обрабатывает выбранную часть текста (с помощью библиотеки 
[Rangy](https://github.com/timdown/rangy)), управляет показом окна ошибки, 
отправляет ошибку в бэкенд. Скрипт использует jQuery.

Скрипт запускается автоматически с параметрами по умолчанию. Если нужно 
настроить параметры запуска, то следует создать объект самостоятельно, в этом 
случае создание автоматически не произойдёт:
```html
<script>
new Lexxpavlov.Spelling({cssErrorClass: 'mistake', callbackUrl: '/send-error/'});
</script>
```

### Параметры скрипта

1. `callbackUrl`: путь к бэкенду, 
по&nbsp;умолчанию:&nbsp;/spelling/new-error
2. `cssErrorClass`: css-класс для текста ошибки, 
по&nbsp;умолчанию:&nbsp;spelling-error
3. `dataDelimiter`: разделитель url ресурса и служебной информации, 
по&nbsp;умолчанию:&nbsp;#@
4. `spelledSelector`: селектор родительского корневого элемента ресурса (см.&nbsp;[ниже](#url-ресурса)), 
по&nbsp;умолчанию:&nbsp;.js-spelling-check
5. `containerSelector`: селектор контейнера окна ошибки, 
по&nbsp;умолчанию:&nbsp;.js-spelling-container
6. `errorSelector`: селектор элемента, показывающего ошибку в окне ошибки, 
по&nbsp;умолчанию:&nbsp;.js-spelling-error
7. `commentSelector`: селектор инпута комментария, 
по&nbsp;умолчанию:&nbsp;.js-spelling-comment
8. `submitSelector`: селектор кнопки отправки ощибки, 
по&nbsp;умолчанию:&nbsp;.js-spelling-send
9. `loadingSelector`: селектор элемента иконки загрузки ответа, 
по&nbsp;умолчанию:&nbsp;.js-spelling-loading
10. `errorsListSelector`: селектор списка ошибок, 
по&nbsp;умолчанию:&nbsp;.js-spelling-errors
11. `closeBtnSelector`: селектор кнопки закрытия окна ошибки, 
по&nbsp;умолчанию:&nbsp;.js-spelling-close
12. `createCallback`: колбэк-функция создания окна ошибки. Если колбэк вернёт 
`false`, то окно ошибки не появится.
13. `buttonCallback`: колбэк-функция нажатия клавиш. Принимает событие `keydown`. 
Используется для смены управляющих клавиш вместо `Ctrl+Enter`.
14. `validateCallback`: колбэк-функция валидации данных. Может использоваться 
для изменения данных перед отправкой. Если колбэк вернёт `false`, то данные не
отправятся.
15. `errorsCallback`: колбэк-функция, запускающаяся при возврате ошибок из 
бэкенда.
16. `getUrlCallback`: колбэк-функция, определяющая url ошибки. 
См.&nbsp;[ниже](#url-ресурса).

Селекторы используются для использования кастомного окна ошибки. См. подробнее 
в разделе [Настройка окна ошибки](error-window.md)

### URL ресурса

На странице может быть несколько различных текстов, требующих проверки 
пользователями (эти тексты далее называются ресурсами). В этом случае каждый 
ресурс должен иметь различный адрес, чтобы потом найти его для коррекции ошибки.
Разные ресурсы размещены в разные элементы (контейнеры), отмеченые css-классом, выбранным в
параметре `spelledSelector`.

Идентифицировать конкретный ресурс можно несколькими способами:

**Первый способ** - указать тип и id ресурса

```html
<ul>
    <li class="js-spelling-check" data-id="1" data-type="article">
        Статья 1
    </li>
    <li class="js-spelling-check" data-id="2" data-type="news" data-prefix="resources">
        Новость 2
    </li>
</ul>
```
В данном случае нужно указать id ресурса, его тип и префикс, где тип можно 
узнать из роута, который будет настраивать этот ресурс. Например, статья 1
будет изменяться роутом `admin_article_edit`, а новость 2 - роутом 
`resources_news_edit`. (Бандл SonataAdminBundle создаёт роуты с названиями 
`admin_{$type}_edit`.)

В этом способе в url страницы добавляется `dataDelimiter`, тип и id ресурса:
```
/articles/#@article=1
/articles/#@news=2=resources
```

**Второй способ** - создать ссылку на страницу с этим ресурсом

Первая ссылка, расположенная в контейнере, имеющая атрибут href, содержит 
ссылку на страницу, в которой этот ресурс находится один, без других ресурсов
(как будто пользователь был на этой странице).
```html
<ul>
    <li class="js-spelling-check">
        <a href="/article/1">Название статьи 1</a>
        <div class="hidden">
            Статья 1
        </div>
    </li>
    <li class="js-spelling-check">
        <a href="/article/2">Название статьи 2</a>
        <div class="hidden">
            Статья 2 
        </div>
    </li>
</ul>
```

**Третий способ** - ваш вариант

Вы можете передать параметром `getUrlCallback` функцию, получаемую корневой 
элемент ресурса, и возвращаемую адрес страницы.
